/*
 Generated by typeshare 1.4.0
 */

import Foundation

public enum FlexPosition: String, Codable {
	case center
	case flexStart = "flex-start"
	case flexEnd = "flex-end"
}

public struct ContainerStylingProperties: Codable {
	public let justifyContent: FlexPosition?
	public let alignItems: FlexPosition?

	public init(justifyContent: FlexPosition?, alignItems: FlexPosition?) {
		self.justifyContent = justifyContent
		self.alignItems = alignItems
	}
}

public struct ColumnStyle: Codable {
	public let container: ContainerStylingProperties?

	public init(container: ContainerStylingProperties?) {
		self.container = container
	}
}

public struct BasicStateStylingBlock<T: Codable>: Codable {
	public let `default`: T
	public let pressed: T?
	public let hovered: T?
	public let disabled: T?

	public init(default: T, pressed: T?, hovered: T?, disabled: T?) {
		self.default = `default`
		self.pressed = pressed
		self.hovered = hovered
		self.disabled = disabled
	}
}

public struct ColumnElements: Codable {
	public let selff: [BasicStateStylingBlock<ColumnStyle>]

	public init(selff: [BasicStateStylingBlock<ColumnStyle>]) {
		self.selff = selff
	}
}

public struct LayoutStyle<T: Codable>: Codable {
	public let elements: T

	public init(elements: T) {
		self.elements = elements
	}
}

public struct ColumnModel<T: Codable>: Codable {
	public let styles: LayoutStyle<ColumnElements>?
	public let children: [T]

	public init(styles: LayoutStyle<ColumnElements>?, children: [T]) {
		self.styles = styles
		self.children = children
	}
}

public struct RowStyle: Codable {
	public let container: ContainerStylingProperties?

	public init(container: ContainerStylingProperties?) {
		self.container = container
	}
}

public struct RowElements: Codable {
	public let selff: [BasicStateStylingBlock<RowStyle>]

	public init(selff: [BasicStateStylingBlock<RowStyle>]) {
		self.selff = selff
	}
}

public struct RowModel<T: Codable>: Codable {
	public let styles: LayoutStyle<RowElements>?
	public let children: [T]

	public init(styles: LayoutStyle<RowElements>?, children: [T]) {
		self.styles = styles
		self.children = children
	}
}

public struct StatelessStylingBlock<T: Codable>: Codable {
	public let `default`: T

	public init(default: T) {
		self.default = `default`
	}
}

public indirect enum LayoutSchemaModel: Codable {
	case row(RowModel<LayoutSchemaModel>)
	case column(ColumnModel<LayoutSchemaModel>)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, schema
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<LayoutSchemaModel>.self, forKey: .schema) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<LayoutSchemaModel>.self, forKey: .schema) {
					self = .column(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(LayoutSchemaModel.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LayoutSchemaModel"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .schema)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .schema)
		}
	}
}
