/*
 Generated by typeshare 1.5.1
 */

import Foundation

public enum DimensionWidthValue: Codable {
	case fixed(Float)
	case percentage(Float)
	case fit(DimensionWidthFitValue)

	enum CodingKeys: String, CodingKey, Codable {
		case fixed,
			percentage,
			fit
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, value
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .fixed:
				if let content = try? container.decode(Float.self, forKey: .value) {
					self = .fixed(content)
					return
				}
			case .percentage:
				if let content = try? container.decode(Float.self, forKey: .value) {
					self = .percentage(content)
					return
				}
			case .fit:
				if let content = try? container.decode(DimensionWidthFitValue.self, forKey: .value) {
					self = .fit(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(DimensionWidthValue.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for DimensionWidthValue"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .fixed(let content):
			try container.encode(CodingKeys.fixed, forKey: .type)
			try container.encode(content, forKey: .value)
		case .percentage(let content):
			try container.encode(CodingKeys.percentage, forKey: .type)
			try container.encode(content, forKey: .value)
		case .fit(let content):
			try container.encode(CodingKeys.fit, forKey: .type)
			try container.encode(content, forKey: .value)
		}
	}
}

public enum DimensionHeightValue: Codable {
	case fixed(Float)
	case percentage(Float)
	case fit(DimensionHeightFitValue)

	enum CodingKeys: String, CodingKey, Codable {
		case fixed,
			percentage,
			fit
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, value
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .fixed:
				if let content = try? container.decode(Float.self, forKey: .value) {
					self = .fixed(content)
					return
				}
			case .percentage:
				if let content = try? container.decode(Float.self, forKey: .value) {
					self = .percentage(content)
					return
				}
			case .fit:
				if let content = try? container.decode(DimensionHeightFitValue.self, forKey: .value) {
					self = .fit(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(DimensionHeightValue.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for DimensionHeightValue"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .fixed(let content):
			try container.encode(CodingKeys.fixed, forKey: .type)
			try container.encode(content, forKey: .value)
		case .percentage(let content):
			try container.encode(CodingKeys.percentage, forKey: .type)
			try container.encode(content, forKey: .value)
		case .fit(let content):
			try container.encode(CodingKeys.fit, forKey: .type)
			try container.encode(content, forKey: .value)
		}
	}
}

public struct DimensionStylingProperties: Codable {
	public let minWidth: Float?
	public let maxWidth: Float?
	public let width: DimensionWidthValue?
	public let minHeight: Float?
	public let maxHeight: Float?
	public let height: DimensionHeightValue?

	public init(minWidth: Float?, maxWidth: Float?, width: DimensionWidthValue?, minHeight: Float?, maxHeight: Float?, height: DimensionHeightValue?) {
		self.minWidth = minWidth
		self.maxWidth = maxWidth
		self.width = width
		self.minHeight = minHeight
		self.maxHeight = maxHeight
		self.height = height
	}
}

public enum FlexChildFlexPosition: String, Codable {
	case center
	case flexStart = "flex-start"
	case flexEnd = "flex-end"
	case stretch
}

public struct FlexChildStylingProperties: Codable {
	public let weight: Float?
	public let order: Int32?
	public let alignSelf: FlexChildFlexPosition

	public init(weight: Float?, order: Int32?, alignSelf: FlexChildFlexPosition) {
		self.weight = weight
		self.order = order
		self.alignSelf = alignSelf
	}
}

public struct SpacingStylingProperties: Codable {
	public let padding: String?
	public let margin: String?
	public let offset: String?

	public init(padding: String?, margin: String?, offset: String?) {
		self.padding = padding
		self.margin = margin
		self.offset = offset
	}
}

public struct ThemeColor: Codable {
	public let light: String
	public let dark: String?

	public init(light: String, dark: String?) {
		self.light = light
		self.dark = dark
	}
}

public struct ThemeUrl: Codable {
	public let light: String
	public let dark: String?

	public init(light: String, dark: String?) {
		self.light = light
		self.dark = dark
	}
}

public enum BackgroundImagePosition: String, Codable {
	case top
	case right
	case bottom
	case left
	case center
	case topRight = "top-right"
	case topLeft = "top-left"
	case bottomLeft = "bottom-left"
	case bottomRight = "bottom-right"
}

public enum BackgroundImageScale: String, Codable {
	case crop
	case fit
	case fill
}

public struct BackgroundImage: Codable {
	public let url: ThemeUrl
	public let position: BackgroundImagePosition?
	public let scale: BackgroundImageScale?

	public init(url: ThemeUrl, position: BackgroundImagePosition?, scale: BackgroundImageScale?) {
		self.url = url
		self.position = position
		self.scale = scale
	}
}

public struct BackgroundStylingProperties: Codable {
	public let backgroundColor: ThemeColor?
	public let backgroundImage: BackgroundImage?

	public init(backgroundColor: ThemeColor?, backgroundImage: BackgroundImage?) {
		self.backgroundColor = backgroundColor
		self.backgroundImage = backgroundImage
	}
}

public enum FontWeight: String, Codable {
	case w100 = "100"
	case w200 = "200"
	case w300 = "300"
	case w400 = "400"
	case w500 = "500"
	case w600 = "600"
	case w700 = "700"
	case w800 = "800"
	case w900 = "900"
}

public enum FontJustification: String, Codable {
	case left
	case right
	case center
	case start
	case end
	case justify
}

public enum FontBaselineAlignment: String, Codable {
	case `super`
	case sub
	case baseline
}

public enum FontStyle: String, Codable {
	case normal
	case italic
}

public enum TextTransform: String, Codable {
	case capitalize
	case uppercase
	case lowercase
	case none
}

public enum TextDecoration: String, Codable {
	case underline
	case strikeThrough = "strike-through"
	case none
}

public struct TextStylingProperties: Codable {
	public let textColor: ThemeColor?
	public let fontSize: Float?
	public let fontFamily: String?
	public let fontWeight: FontWeight?
	public let lineHeight: Float?
	public let horizontalTextAlign: FontJustification?
	public let baselineTextAlign: FontBaselineAlignment?
	public let fontStyle: FontStyle?
	public let textTransform: TextTransform?
	public let letterSpacing: Float?
	public let textDecoration: TextDecoration?
	public let lineLimit: Int32?

	public init(textColor: ThemeColor?, fontSize: Float?, fontFamily: String?, fontWeight: FontWeight?, lineHeight: Float?, horizontalTextAlign: FontJustification?, baselineTextAlign: FontBaselineAlignment?, fontStyle: FontStyle?, textTransform: TextTransform?, letterSpacing: Float?, textDecoration: TextDecoration?, lineLimit: Int32?) {
		self.textColor = textColor
		self.fontSize = fontSize
		self.fontFamily = fontFamily
		self.fontWeight = fontWeight
		self.lineHeight = lineHeight
		self.horizontalTextAlign = horizontalTextAlign
		self.baselineTextAlign = baselineTextAlign
		self.fontStyle = fontStyle
		self.textTransform = textTransform
		self.letterSpacing = letterSpacing
		self.textDecoration = textDecoration
		self.lineLimit = lineLimit
	}
}

public struct BasicTextStyle: Codable {
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?
	public let background: BackgroundStylingProperties?
	public let text: TextStylingProperties?

	public init(dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?, background: BackgroundStylingProperties?, text: TextStylingProperties?) {
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
		self.background = background
		self.text = text
	}
}

public struct BasicStateStylingBlock<T: Codable>: Codable {
	public let `default`: T
	public let pressed: T?
	public let hovered: T?
	public let disabled: T?

	public init(default: T, pressed: T?, hovered: T?, disabled: T?) {
		self.default = `default`
		self.pressed = pressed
		self.hovered = hovered
		self.disabled = disabled
	}
}

public struct BasicTextElements: Codable {
	public let own: [BasicStateStylingBlock<BasicTextStyle>]

	public init(own: [BasicStateStylingBlock<BasicTextStyle>]) {
		self.own = own
	}
}

public struct LayoutStyle<T: Codable>: Codable {
	public let elements: T

	public init(elements: T) {
		self.elements = elements
	}
}

public struct BasicTextModel: Codable {
	public let styles: LayoutStyle<BasicTextElements>?
	public let value: String

	public init(styles: LayoutStyle<BasicTextElements>?, value: String) {
		self.styles = styles
		self.value = value
	}
}

public enum FlexPosition: String, Codable {
	case center
	case flexStart = "flex-start"
	case flexEnd = "flex-end"
}

public struct ContainerStylingProperties: Codable {
	public let justifyContent: FlexPosition?
	public let alignItems: FlexPosition?

	public init(justifyContent: FlexPosition?, alignItems: FlexPosition?) {
		self.justifyContent = justifyContent
		self.alignItems = alignItems
	}
}

public enum BorderStyle: String, Codable {
	case solid = "Solid"
	case dashed = "Dashed"
}

public struct BorderStylingProperties: Codable {
	public let borderRadius: Float?
	public let borderColor: ThemeColor?
	public let borderWidth: Float?
	public let borderStyle: BorderStyle?

	public init(borderRadius: Float?, borderColor: ThemeColor?, borderWidth: Float?, borderStyle: BorderStyle?) {
		self.borderRadius = borderRadius
		self.borderColor = borderColor
		self.borderWidth = borderWidth
		self.borderStyle = borderStyle
	}
}

public struct ColumnStyle: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct ColumnElements: Codable {
	public let own: [BasicStateStylingBlock<ColumnStyle>]

	public init(own: [BasicStateStylingBlock<ColumnStyle>]) {
		self.own = own
	}
}

public struct ColumnModel<T: Codable>: Codable {
	public let styles: LayoutStyle<ColumnElements>?
	public let children: [T]

	public init(styles: LayoutStyle<ColumnElements>?, children: [T]) {
		self.styles = styles
		self.children = children
	}
}

public struct CreativeResponseStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct CreativeResponseElements: Codable {
	public let own: [BasicStateStylingBlock<CreativeResponseStyles>]

	public init(own: [BasicStateStylingBlock<CreativeResponseStyles>]) {
		self.own = own
	}
}

public struct CreativeResponseModel<T: Codable>: Codable {
	public let responseKey: String
	public let styles: LayoutStyle<CreativeResponseElements>?
	public let children: [T]

	public init(responseKey: String, styles: LayoutStyle<CreativeResponseElements>?, children: [T]) {
		self.responseKey = responseKey
		self.styles = styles
		self.children = children
	}
}

public struct ImageStyles: Codable {
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct ImageElements: Codable {
	public let own: [BasicStateStylingBlock<ImageStyles>]

	public init(own: [BasicStateStylingBlock<ImageStyles>]) {
		self.own = own
	}
}

public struct ImageUrl: Codable {
	public let light: String
	public let dark: String?

	public init(light: String, dark: String?) {
		self.light = light
		self.dark = dark
	}
}

public struct ImageModel: Codable {
	public let styles: LayoutStyle<ImageElements>?
	public let alt: String?
	public let url: ImageUrl

	public init(styles: LayoutStyle<ImageElements>?, alt: String?, url: ImageUrl) {
		self.styles = styles
		self.alt = alt
		self.url = url
	}
}

public struct OneByOneDistributionStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct OneByOneDistributionElements: Codable {
	public let own: [BasicStateStylingBlock<OneByOneDistributionStyles>]

	public init(own: [BasicStateStylingBlock<OneByOneDistributionStyles>]) {
		self.own = own
	}
}

public struct FadeInOutTransitionSettings: Codable {
	public let duration: Int32

	public init(duration: Int32) {
		self.duration = duration
	}
}

public enum Transition: Codable {
	case fadeInOut(FadeInOutTransitionSettings)

	enum CodingKeys: String, CodingKey, Codable {
		case fadeInOut = "FadeInOut"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, settings
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .fadeInOut:
				if let content = try? container.decode(FadeInOutTransitionSettings.self, forKey: .settings) {
					self = .fadeInOut(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(Transition.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for Transition"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .fadeInOut(let content):
			try container.encode(CodingKeys.fadeInOut, forKey: .type)
			try container.encode(content, forKey: .settings)
		}
	}
}

public struct OneByOneDistributionModel: Codable {
	public let styles: LayoutStyle<OneByOneDistributionElements>?
	public let transition: Transition

	public init(styles: LayoutStyle<OneByOneDistributionElements>?, transition: Transition) {
		self.styles = styles
		self.transition = transition
	}
}

public struct OverlayStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct OverlayWrapperStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?) {
		self.container = container
		self.background = background
	}
}

public struct OverlayElements: Codable {
	public let own: [BasicStateStylingBlock<OverlayStyles>]
	public let overlayWrapper: [BasicStateStylingBlock<OverlayWrapperStyles>]

	public init(own: [BasicStateStylingBlock<OverlayStyles>], overlayWrapper: [BasicStateStylingBlock<OverlayWrapperStyles>]) {
		self.own = own
		self.overlayWrapper = overlayWrapper
	}
}

public struct OverlaySettings: Codable {
	public let allowBackdropToClose: Bool

	public init(allowBackdropToClose: Bool) {
		self.allowBackdropToClose = allowBackdropToClose
	}
}

public struct OverlayModel<T: Codable>: Codable {
	public let settings: OverlaySettings
	public let styles: LayoutStyle<OverlayElements>?
	public let children: [T]

	public init(settings: OverlaySettings, styles: LayoutStyle<OverlayElements>?, children: [T]) {
		self.settings = settings
		self.styles = styles
		self.children = children
	}
}

public struct IndicatorStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?
	public let text: TextStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?, text: TextStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
		self.text = text
	}
}

public struct ProgressIndicatorStyles: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct ProgressIndicatorElements: Codable {
	public let own: [BasicStateStylingBlock<ProgressIndicatorStyles>]
	public let indicator: [BasicStateStylingBlock<IndicatorStyles>]
	public let activeIndicator: [BasicStateStylingBlock<IndicatorStyles>]

	public init(own: [BasicStateStylingBlock<ProgressIndicatorStyles>], indicator: [BasicStateStylingBlock<IndicatorStyles>], activeIndicator: [BasicStateStylingBlock<IndicatorStyles>]) {
		self.own = own
		self.indicator = indicator
		self.activeIndicator = activeIndicator
	}
}

public struct ProgressIndicatorModel: Codable {
	public let styles: LayoutStyle<ProgressIndicatorElements>?
	public let indicator: String

	public init(styles: LayoutStyle<ProgressIndicatorElements>?, indicator: String) {
		self.styles = styles
		self.indicator = indicator
	}
}

public struct RichTextStyle: Codable {
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?
	public let background: BackgroundStylingProperties?
	public let text: TextStylingProperties?

	public init(dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?, background: BackgroundStylingProperties?, text: TextStylingProperties?) {
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
		self.background = background
		self.text = text
	}
}

public struct RichTextElements: Codable {
	public let own: [BasicStateStylingBlock<RichTextStyle>]

	public init(own: [BasicStateStylingBlock<RichTextStyle>]) {
		self.own = own
	}
}

public struct RichTextModel: Codable {
	public let styles: LayoutStyle<RichTextElements>?
	public let value: String

	public init(styles: LayoutStyle<RichTextElements>?, value: String) {
		self.styles = styles
		self.value = value
	}
}

public struct RowStyle: Codable {
	public let container: ContainerStylingProperties?
	public let background: BackgroundStylingProperties?
	public let border: BorderStylingProperties?
	public let dimension: DimensionStylingProperties?
	public let flexChild: FlexChildStylingProperties?
	public let spacing: SpacingStylingProperties?

	public init(container: ContainerStylingProperties?, background: BackgroundStylingProperties?, border: BorderStylingProperties?, dimension: DimensionStylingProperties?, flexChild: FlexChildStylingProperties?, spacing: SpacingStylingProperties?) {
		self.container = container
		self.background = background
		self.border = border
		self.dimension = dimension
		self.flexChild = flexChild
		self.spacing = spacing
	}
}

public struct RowElements: Codable {
	public let own: [BasicStateStylingBlock<RowStyle>]

	public init(own: [BasicStateStylingBlock<RowStyle>]) {
		self.own = own
	}
}

public struct RowModel<T: Codable>: Codable {
	public let styles: LayoutStyle<RowElements>?
	public let children: [T]

	public init(styles: LayoutStyle<RowElements>?, children: [T]) {
		self.styles = styles
		self.children = children
	}
}

public struct StatelessStylingBlock<T: Codable>: Codable {
	public let `default`: T

	public init(default: T) {
		self.default = `default`
	}
}

public indirect enum LayoutSchemaModel: Codable {
	case row(RowModel<LayoutSchemaModel>)
	case column(ColumnModel<LayoutSchemaModel>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case progressIndicator(ProgressIndicatorModel)
	case creativeResponse(CreativeResponseModel<LayoutSchemaModel>)
	case oneByOneDistribution(OneByOneDistributionModel)
	case overlay(OverlayModel<LayoutSchemaModel>)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			progressIndicator = "ProgressIndicator",
			creativeResponse = "CreativeResponse",
			oneByOneDistribution = "OneByOneDistribution",
			overlay = "Overlay"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<LayoutSchemaModel>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<LayoutSchemaModel>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .progressIndicator:
				if let content = try? container.decode(ProgressIndicatorModel.self, forKey: .node) {
					self = .progressIndicator(content)
					return
				}
			case .creativeResponse:
				if let content = try? container.decode(CreativeResponseModel<LayoutSchemaModel>.self, forKey: .node) {
					self = .creativeResponse(content)
					return
				}
			case .oneByOneDistribution:
				if let content = try? container.decode(OneByOneDistributionModel.self, forKey: .node) {
					self = .oneByOneDistribution(content)
					return
				}
			case .overlay:
				if let content = try? container.decode(OverlayModel<LayoutSchemaModel>.self, forKey: .node) {
					self = .overlay(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(LayoutSchemaModel.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LayoutSchemaModel"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .progressIndicator(let content):
			try container.encode(CodingKeys.progressIndicator, forKey: .type)
			try container.encode(content, forKey: .node)
		case .creativeResponse(let content):
			try container.encode(CodingKeys.creativeResponse, forKey: .type)
			try container.encode(content, forKey: .node)
		case .oneByOneDistribution(let content):
			try container.encode(CodingKeys.oneByOneDistribution, forKey: .type)
			try container.encode(content, forKey: .node)
		case .overlay(let content):
			try container.encode(CodingKeys.overlay, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public enum LayoutVariantSchemaModel: Codable {
	case row(RowModel<LayoutVariantChildren>)
	case column(ColumnModel<LayoutVariantChildren>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case creativeResponse(CreativeResponseModel<CreativeResponseChildren>)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			creativeResponse = "CreativeResponse"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<LayoutVariantChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<LayoutVariantChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .creativeResponse:
				if let content = try? container.decode(CreativeResponseModel<CreativeResponseChildren>.self, forKey: .node) {
					self = .creativeResponse(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(LayoutVariantSchemaModel.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LayoutVariantSchemaModel"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .creativeResponse(let content):
			try container.encode(CodingKeys.creativeResponse, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public indirect enum LayoutVariantChildren: Codable {
	case row(RowModel<LayoutVariantChildren>)
	case column(ColumnModel<LayoutVariantChildren>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case creativeResponse(CreativeResponseModel<CreativeResponseChildren>)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			creativeResponse = "CreativeResponse"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<LayoutVariantChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<LayoutVariantChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .creativeResponse:
				if let content = try? container.decode(CreativeResponseModel<CreativeResponseChildren>.self, forKey: .node) {
					self = .creativeResponse(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(LayoutVariantChildren.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for LayoutVariantChildren"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .creativeResponse(let content):
			try container.encode(CodingKeys.creativeResponse, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public enum OuterLayoutSchemaModel: Codable {
	case row(RowModel<OuterLayoutChildren>)
	case column(ColumnModel<OuterLayoutChildren>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case progressIndicator(ProgressIndicatorModel)
	case oneByOneDistribution(OneByOneDistributionModel)
	case overlay(OverlayModel<OverlayChildren>)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			progressIndicator = "ProgressIndicator",
			oneByOneDistribution = "OneByOneDistribution",
			overlay = "Overlay"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<OuterLayoutChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<OuterLayoutChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .progressIndicator:
				if let content = try? container.decode(ProgressIndicatorModel.self, forKey: .node) {
					self = .progressIndicator(content)
					return
				}
			case .oneByOneDistribution:
				if let content = try? container.decode(OneByOneDistributionModel.self, forKey: .node) {
					self = .oneByOneDistribution(content)
					return
				}
			case .overlay:
				if let content = try? container.decode(OverlayModel<OverlayChildren>.self, forKey: .node) {
					self = .overlay(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(OuterLayoutSchemaModel.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for OuterLayoutSchemaModel"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .progressIndicator(let content):
			try container.encode(CodingKeys.progressIndicator, forKey: .type)
			try container.encode(content, forKey: .node)
		case .oneByOneDistribution(let content):
			try container.encode(CodingKeys.oneByOneDistribution, forKey: .type)
			try container.encode(content, forKey: .node)
		case .overlay(let content):
			try container.encode(CodingKeys.overlay, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public indirect enum OuterLayoutChildren: Codable {
	case row(RowModel<OuterLayoutChildren>)
	case column(ColumnModel<OuterLayoutChildren>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case progressIndicator(ProgressIndicatorModel)
	case oneByOneDistribution(OneByOneDistributionModel)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			progressIndicator = "ProgressIndicator",
			oneByOneDistribution = "OneByOneDistribution"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<OuterLayoutChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<OuterLayoutChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .progressIndicator:
				if let content = try? container.decode(ProgressIndicatorModel.self, forKey: .node) {
					self = .progressIndicator(content)
					return
				}
			case .oneByOneDistribution:
				if let content = try? container.decode(OneByOneDistributionModel.self, forKey: .node) {
					self = .oneByOneDistribution(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(OuterLayoutChildren.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for OuterLayoutChildren"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .progressIndicator(let content):
			try container.encode(CodingKeys.progressIndicator, forKey: .type)
			try container.encode(content, forKey: .node)
		case .oneByOneDistribution(let content):
			try container.encode(CodingKeys.oneByOneDistribution, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public indirect enum CreativeResponseChildren: Codable {
	case row(RowModel<CreativeResponseChildren>)
	case column(ColumnModel<CreativeResponseChildren>)
	case basicText(BasicTextModel)
	case image(ImageModel)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			basicText = "BasicText",
			image = "Image"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<CreativeResponseChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<CreativeResponseChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(CreativeResponseChildren.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for CreativeResponseChildren"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public indirect enum OverlayChildren: Codable {
	case row(RowModel<OverlayChildren>)
	case column(ColumnModel<OverlayChildren>)
	case image(ImageModel)
	case richText(RichTextModel)
	case basicText(BasicTextModel)
	case progressIndicator(ProgressIndicatorModel)
	case oneByOneDistribution(OneByOneDistributionModel)

	enum CodingKeys: String, CodingKey, Codable {
		case row = "Row",
			column = "Column",
			image = "Image",
			richText = "RichText",
			basicText = "BasicText",
			progressIndicator = "ProgressIndicator",
			oneByOneDistribution = "OneByOneDistribution"
	}

	private enum ContainerCodingKeys: String, CodingKey {
		case type, node
	}

	public init(from decoder: Decoder) throws {
		let container = try decoder.container(keyedBy: ContainerCodingKeys.self)
		if let type = try? container.decode(CodingKeys.self, forKey: .type) {
			switch type {
			case .row:
				if let content = try? container.decode(RowModel<OverlayChildren>.self, forKey: .node) {
					self = .row(content)
					return
				}
			case .column:
				if let content = try? container.decode(ColumnModel<OverlayChildren>.self, forKey: .node) {
					self = .column(content)
					return
				}
			case .image:
				if let content = try? container.decode(ImageModel.self, forKey: .node) {
					self = .image(content)
					return
				}
			case .richText:
				if let content = try? container.decode(RichTextModel.self, forKey: .node) {
					self = .richText(content)
					return
				}
			case .basicText:
				if let content = try? container.decode(BasicTextModel.self, forKey: .node) {
					self = .basicText(content)
					return
				}
			case .progressIndicator:
				if let content = try? container.decode(ProgressIndicatorModel.self, forKey: .node) {
					self = .progressIndicator(content)
					return
				}
			case .oneByOneDistribution:
				if let content = try? container.decode(OneByOneDistributionModel.self, forKey: .node) {
					self = .oneByOneDistribution(content)
					return
				}
			}
		}
		throw DecodingError.typeMismatch(OverlayChildren.self, DecodingError.Context(codingPath: decoder.codingPath, debugDescription: "Wrong type for OverlayChildren"))
	}

	public func encode(to encoder: Encoder) throws {
		var container = encoder.container(keyedBy: ContainerCodingKeys.self)
		switch self {
		case .row(let content):
			try container.encode(CodingKeys.row, forKey: .type)
			try container.encode(content, forKey: .node)
		case .column(let content):
			try container.encode(CodingKeys.column, forKey: .type)
			try container.encode(content, forKey: .node)
		case .image(let content):
			try container.encode(CodingKeys.image, forKey: .type)
			try container.encode(content, forKey: .node)
		case .richText(let content):
			try container.encode(CodingKeys.richText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .basicText(let content):
			try container.encode(CodingKeys.basicText, forKey: .type)
			try container.encode(content, forKey: .node)
		case .progressIndicator(let content):
			try container.encode(CodingKeys.progressIndicator, forKey: .type)
			try container.encode(content, forKey: .node)
		case .oneByOneDistribution(let content):
			try container.encode(CodingKeys.oneByOneDistribution, forKey: .type)
			try container.encode(content, forKey: .node)
		}
	}
}

public enum DimensionWidthFitValue: String, Codable {
	case wrapContent = "wrap-content"
	case fitWidth = "fit-width"
}

public enum DimensionHeightFitValue: String, Codable {
	case wrapContent = "wrap-content"
	case fitHeight = "fit-height"
}
